#!/bin/sh

. /usr/share/debconf/confmodule

error () {
    logger -t migration-assistant "error: $@"
}

log () {
    logger -t migration-assistant "info: $@"
}

ostype=""
set_os_type () {
# Rather than test for every distro possible in the shortname, we test
# the bootloader type for 'linux.'  This *should* be fine as we're only
# working with user's home directories.

    if [ ${1##*:} = "linux" ]; then
	ostype="linux"
	return
    fi
    
    case `expr match "$1" '.*:.*:\(.*\):.*'` in
	"Windows" )
	ostype="windowsxp"
	;;

	"Windows9xMe" )
	ostype="windows9x"
	;;

	"MacOSX" )
	ostype="macosx"
	;;

    *)
    echo "Unknown ostype from $1" 1>&2
    ;;
    esac
}
mountpoint="/mnt/migrationassistant"

unmount_os() {
    device="$1"

    if [ -f /etc/mtab ]; then
        MTAB=/etc/mtab
    else
        MTAB=/proc/mounts
    fi

    while :; do
        failed=
        
	ISMOUNTED=
	if [ "$device" ]; then
		ISMOUNTED=$(grep "$device" $MTAB) || ISMOUNTED=
	else
		ISMOUNTED=$(grep "$mountpoint" $MTAB) || ISMOUNTED=
	fi
        if [ -z "$ISMOUNTED" ]; then
	        break
        fi
        HOME=$(grep "$mountpoint/home" $MTAB) || HOME=
        if [ "$HOME" ]; then
            umount "$mountpoint/home" || failed="$mountpoint/home"
        fi
        if [ -z "$failed" ]; then
            if [ -z "$device" ]; then
                umount $mountpoint || failed="$mountpoint"
            else
                umount $device || failed="$device"
            fi
        fi

        if [ -z "$failed" ]; then
            break
        fi
        db_reset migration-assistant/failed-unmount
        db_subst migration-assistant/failed-unmount MOUNTED "$failed"
        db_input critical migration-assistant/failed-unmount || true
        db_go || exit 10
        db_get migration-assistant/failed-unmount
        [ "$RET" = true ] || exit 10
    done
}

mount_os () {
    ostype="$1"
    device="$2"

    mkdir -p $mountpoint
	unmount_os $device

    if [ "$1" = "linux" ]; then
	    mount $device $mountpoint
        # All this, just to get /home...
	# FIXME: we'll probably need to check if /etc is its own part as well.
	if [ -f "$mountpoint/etc/fstab" ]; then
            while read uuid mp rest; do
	    	if [ "$mp" != "/home" ]; then
			continue
		fi

		if [ "${uuid%=*}" = "UUID" ]; then
			uuid=$(readlink -e "/dev/disk/by-uuid/${uuid#*=}")
		elif [ "${uuid%=*}" = "LABEL" ]; then
			uuid=$(readlink -e "/dev/disk/by-label/${uuid#*=}")
                fi
                failed=
		mount $uuid "$mountpoint/home" || failed="1"
                if [ "$failed" ]; then
			unmount_os "$uuid"
			mount $uuid "$mountpoint/home"
		fi
		break
            done < "$mountpoint/etc/fstab"
        fi
    elif [ "$1" = "windowsxp" ]; then
		mount -t ntfs $device $mountpoint -o umask=0022,nls=utf8 || \
		log "Windows XP drive is not NTFS formatted or error, trying vfat"; \
		mount -t vfat $device $mountpoint -o umask=0022,utf8 || \
		log "Mounting with vfat didn't work."
    fi

}

ROOT=/target
add_user() {
    local username
    local fullname
    local password

    username="$1"
    fullname="$2"
    password="$3"

    chroot=chroot
    log='log-output -t migration-assistant'

# Taken from user-setup/user-setup-apply

	# Add the user
	if [ -x $ROOT/usr/sbin/adduser ]; then
		$chroot $ROOT adduser --disabled-password --gecos \
		"$fullname" "$username" >/dev/null || true
	else
		$chroot $ROOT useradd -c "$fullname" -m "$username" >/dev/null || true
	fi

	# Set the password
	$chroot $ROOT chpasswd -m <<EOF
$username:$password
EOF

	# Add the user to groups
	if [ -n "$username" ]; then
		for group in adm audio cdrom dialout floppy video plugdev dip lpadmin scanner; do
			#$log 
			$chroot $ROOT adduser "$username" $group >/dev/null 2>&1 || true
		done

	fi
}
