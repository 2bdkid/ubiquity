#!/bin/sh

# TODO: Incorporate capb backup.

set -e
. /usr/share/debconf/confmodule
. /usr/share/migration-assistant/ma-script-utils


if [ -z "$1" ]; then
    mapath="/usr/bin"
else
    mapath="$1"
fi

unmount_os

#FIXME: need a better solution.
OLDIFS="$IFS"
IFS='
'
tmp=""
for line in `os-prober`;
do
    dist=$(expr match "$line" '.*:\(.*\):.*:.*')
    location=$(expr match "$line" '\(.*\):.*:.*:.*')
    tmp="$tmp$dist ($location), "
done
tmp=${tmp%,*}

IFS="$OLDIFS"

db_subst migration-assistant/partitions choices "$tmp"
db_input high migration-assistant/partitions || true
db_go || exit 10

db_get migration-assistant/partitions
NEWLINE='
'
IFS="$NEWLINE"
selection=`echo "$RET" | sed -e 's/, /\n/g'`
if [ -z "$selection" ]; then
    exit
fi
for choice in $selection; # Microsoft Windows XP Professional (/dev/hda1)
do
    location=`expr "$choice" : '.*(\(.*\))$'` # /dev/hda1
    for line in `os-prober`;
    do
	loc="${line%%:*}"
	# make this not if continue, so we can save an indentation
	if [ $location = $loc ]
	then
	    set_os_type $line

	    path="${loc#*/*/}" # hda1 or discs/disc0/part1
	    mount_os "$ostype" "$loc"
	    IFS="$OLDIFS"
	    db_register migration-assistant/users migration-assistant/$path/users
	    db_subst migration-assistant/$path/users user-choices "$($mapath/ma-search-users "$ostype" "$mountpoint")"
	    db_subst migration-assistant/$path/users os-type "$choice"
	    

	    db_input high migration-assistant/$path/users || true
	    db_go || exit 10

	    db_get migration-assistant/$path/users

	    user_selection=`echo "$RET" | sed -e 's/, /\n/g'`
	    for usr in $user_selection;
	    do
		itemsret=$($mapath/ma-search-items --path="$mountpoint" --ostype="$ostype" --user="$usr")
		db_register migration-assistant/items migration-assistant/$path/$usr/items
		db_subst migration-assistant/$path/$usr/items choices "$itemsret"
		db_subst migration-assistant/$path/$usr/items user "$usr"


		# migration-assistant/discs/disc0/part1/Evan/items
		db_input high migration-assistant/$path/$usr/items || true
		db_go || exit 10
		

		db_register migration-assistant/user migration-assistant/$path/$usr/user
		# This prevents m-a from working right. change to choices
		#db_set migration-assistant/$path/$usr/user "$(echo "$usr" | tr '[A-Z]' '[a-z]')"
		db_subst migration-assistant/$path/$usr/user old-user "$usr"

		while [ true ]; do
			db_get migration-assistant/$path/$usr/user || true
			new_user="$RET"

			db_input high migration-assistant/$path/$usr/user || true
			db_go || exit 10
			
			db_get migration-assistant/$path/$usr/user
			if [ "$RET" = "skip-question" ]; then
				db_set migration-assistant/$path/$usr/user "$new_user"
				break
			fi

			new_user="$RET"
			
			if ! LC_ALL=C expr "$new_user" : '[a-z][-a-z0-9]*$' >/dev/null; then
				db_fset migration-assistant/$path/$usr/user seen false
				db_fset migration-assistant/username-bad seen false
				db_subst migration-assistant/username-bad user "$new_user"
				db_input critical migration-assistant/username-bad
				continue
			fi
			
			# TODO: Either copy this or depend on user-setup.
			if grep -v '^#' /usr/lib/user-setup/reserved-usernames | \
			   grep -q "^$new_user\$"; then
				db_fset migration-assistant/$path/$usr/user seen false
				db_fset migration-assistant/username-reserved seen false
				db_subst migration-assistant/username-reserved user "$new_user"
				db_input critical migration-assistant/username-reserved
				continue
			fi
			break
		done

		# Only ask if the user doesn't match the one seeded for
		# user-setup.
		db_get passwd/username || true
		if [ "$new_user" = "$RET" ]; then
		    continue
		fi

		# Password
		db_register migration-assistant/password migration-assistant/new-user/$new_user/password
		db_subst migration-assistant/new-user/$new_user/password user "$new_user"

		db_register migration-assistant/password-again migration-assistant/new-user/$new_user/password-again
		db_subst migration-assistant/new-user/$new_user/password-again user "$new_user"

		while [ true ]; do

		    db_get migration-assistant/new-user/$new_user/password || true
		    pass=$RET
		    
		    db_input high migration-assistant/new-user/$new_user/password || true
		    db_go || exit 10
		    db_get migration-assistant/new-user/$new_user/password || true
		    
		    if [ "$RET" = "skip-question" ]; then
		    	db_set migration-assistant/new-user/$new_user/password "$pass"
			break
		    fi
		    
		    pass=$RET

		    db_input high migration-assistant/new-user/$new_user/password-again || true
		    db_go || exit 10
		    db_get migration-assistant/new-user/$new_user/password-again || true
		    pass2=$RET
		    
		    if [ -z "$pass2" ] || [ -z "$pass" ]; then
		    	db_set migration-assistant/new-user/$new_user/password ""
		    	db_set migration-assistant/new-user/$new_user/password-again ""
		    	db_fset migration-assistant/password-empty seen "false"
		    	db_input high migration-assistant/password-empty || true
		    	db_fset migration-assistant/new-user/$new_user/password seen "false"
		    	db_fset migration-assistant/new-user/$new_user/password-again seen "false"
		    	db_go || true
		    	
			continue
		    fi

		    if [ "$pass2" = "$pass" ]; then
			break
		    else
		    	db_set migration-assistant/new-user/$new_user/password ""
		    	db_set migration-assistant/new-user/$new_user/password-again ""
		    	db_fset migration-assistant/password-mismatch seen "false"
		    	db_input high migration-assistant/password-mismatch || true
		    	db_fset migration-assistant/new-user/$new_user/password seen "false"
		    	db_fset migration-assistant/new-user/$new_user/password-again seen "false"
		    	db_go || true
		    fi

		done

		
		# Full Name
		db_register migration-assistant/fullname migration-assistant/new-user/$new_user/fullname
		db_subst migration-assistant/new-user/$new_user/fullname user "$new_user"

		db_input high migration-assistant/new-user/$new_user/fullname || true
		db_go || exit 10
		
	    done
	    IFS="$NEWLINE"
	    unmount_os
	fi
    done
done
